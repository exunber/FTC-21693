package org.firstinspires.ftc.teamcode.full_code;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;

@Autonomous(name="Robot: Auto Drive By Encoder", group="Robot")
public class full_auto_V1 extends LinearOpMode {

    private DcMotor fl = null;
    private DcMotor fr = null;
    private DcMotor bl = null;
    private DcMotor br = null;

    private ElapsedTime runtime = new ElapsedTime();

    // Correct encoder resolution for GoBilda 312 RPM motors
    static final double COUNTS_PER_MOTOR_REV = 537.6;
    static final double DRIVE_GEAR_REDUCTION = 19.2;
    static final double WHEEL_DIAMETER_INCHES = 4.1;
    static final double COUNTS_PER_INCH = (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_REDUCTION) /
            (WHEEL_DIAMETER_INCHES * Math.PI);
    static final double DRIVE_SPEED = .3;
    static final double TURN_SPEED = 0.5;

    @Override
    public void runOpMode() {

        fl = hardwareMap.get(DcMotor.class, "fl");
        fr = hardwareMap.get(DcMotor.class, "fr");
        bl = hardwareMap.get(DcMotor.class, "bl");
        br = hardwareMap.get(DcMotor.class, "br");

        fl.setDirection(DcMotor.Direction.REVERSE);
        bl.setDirection(DcMotor.Direction.REVERSE);
        fr.setDirection(DcMotor.Direction.FORWARD);
        br.setDirection(DcMotor.Direction.FORWARD);

        resetEncoders();

        telemetry.addData("Status", "Encoders Reset");
        telemetry.addData("Counts per Inch", COUNTS_PER_INCH);
        telemetry.update();
        
        waitForStart();

        encoderDrive(DRIVE_SPEED, 3, 3, 5.0);  // Move forward 20 inches

        telemetry.addData("Path", "Complete");
        telemetry.update();
        sleep(1000);
    }

    public void encoderDrive(double speed, double leftInches, double rightInches, double timeoutS) {
        resetEncoders();

        int newFlTarget = (int)(leftInches * COUNTS_PER_INCH);
        int newBlTarget = (int)(leftInches * COUNTS_PER_INCH);
        int newFrTarget = (int)(rightInches * COUNTS_PER_INCH);
        int newBrTarget = (int)(rightInches * COUNTS_PER_INCH);

        fl.setTargetPosition(newFlTarget);
        fr.setTargetPosition(newFrTarget);
        bl.setTargetPosition(newBlTarget);
        br.setTargetPosition(newBrTarget);

        fl.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        fr.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        bl.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        br.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        fl.setPower(Math.abs(speed));
        fr.setPower(Math.abs(speed));
        bl.setPower(Math.abs(speed));
        br.setPower(Math.abs(speed));

        runtime.reset();
        while (opModeIsActive() &&
                (runtime.seconds() < timeoutS) &&
                (fl.isBusy() && fr.isBusy() && bl.isBusy() && br.isBusy())) {

            telemetry.addData("Target", "%d %d %d %d", newFlTarget, newFrTarget, newBlTarget, newBrTarget);
            telemetry.addData("Current", "%d %d %d %d",
                    fl.getCurrentPosition(),
                    fr.getCurrentPosition(),
                    bl.getCurrentPosition(),
                    br.getCurrentPosition());
            telemetry.update();
        }

        fl.setPower(0);
        fr.setPower(0);
        bl.setPower(0);
        br.setPower(0);

        fl.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        fr.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        bl.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        br.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        sleep(250);
    }

    private void resetEncoders() {
        fl.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        fr.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        bl.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        br.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        fl.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        fr.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        bl.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        br.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    }
}
